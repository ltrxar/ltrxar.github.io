<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Scenario 2 - LTRXAR</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Scenario 2";
        var mkdocs_page_input_path = "scenario_2.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> LTRXAR
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../about/">About This Lab</a>
                  </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Scenario 2</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sc_2_validation/">Validation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sc_2_cont_edu/">Continue Your Education</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../appendix/">Appendix</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">LTRXAR</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>Scenario 2</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="scenario-2">Scenario 2</h1>
<p>Welcome to Scenario 2! Here, we will walk step by step to understand EXACTLY what occurs when using the Onramp functionality within the Viptela SD-WAN solution.  </p>
<p>Firstly, why do I care about extending the SD-WAN fabric to AWS?  Extending the SD-WAN fabric as close to the source/destination has the obvious benefit of maintaining segmentation (which VPNs (Virtual Private Networks) can connect to which host VPCs), but also it allows us to leverage capabilities like application aware routing to ensure we're using the BEST transit possible.<br />
Should I care about this, really? Are you asking this question because you already have a direct connect with AWS? Then no, this is useless information, and you can skip to the last page where we have a coupon for a free Shania Twain concert ticket!
(Just kidding)
You MIGHT care if you are not wanting to have to backhaul all your remote site application traffic through your point of AWS direct connect.  Some/most customers leverage a direct connect in a main campus location, so this means that your remote sites must traverse the various transports available to get to the campus only to then use the direct connect to AWS.  An alternative option is to use a direct internet connection so that your branch sites can get a direct (over the internet) path to the cloud-hosted application. Let us assume your branch site is already using a commercial internet circuit as one of its transports…so why not cut out the middleman!
Why am I using Ansible to do this? Can't I just use the GUI? Sure, but would you understand the SPECIFIC APIs OR the specific options available to extend the SD-WAN fabric? Furthermore, if you do not know ANYTHING (or very little) about Ansible, this session will leave you with an understanding of what could be possible.  </p>
<p>Just because you can does not mean you should.<br />
Because you can, means you should. (for fun)</p>
<ol>
<li>Navigate back to the Windows jumphost.  The AWS instance should have been requested in the environment setup, but if you didn’t already, please do so now.  Reminder, this takes a few minutes to complete  </li>
<li>Click on ‘Go to Account’  </li>
<li>Search for ‘VPC’ &amp; click on it.  </li>
</ol>
<p><img alt="Screenshot" src="../img/Picture1.png" /></p>
<p>Review the x2 VPCs that are present.    <br />
Note: If you’re not familiar with the concept of AWS VPCs, a VPC (or virtual private cloud) enables you to launch AWS resources into a virtual network that you've defined. This virtual network closely resembles a traditional network that you'd operate in your own data center, with the benefits of using the scalable infrastructure of AWS.<br />
The following diagram shows an example VPC. The VPC has one subnet in each of the Availability Zones in the Region.  A typical VPC definition includes a network (10.0.0.0/16 in this image) that can then be subnetted into smaller networks (10.0.1.0/24 &amp; 10.0.2.0/24).  </p>
<p><img alt="Screenshot" src="../img/Picture2.png" /></p>
<p>Note: There are two host VPCs in our lab environment.  Success for Scenario 2 is deployment of Cloud OnRamp for Multicloud and validation that we’ve associated specific VPNs to specific VPCs, which can be verified by the routes associated with the VPCs.  </p>
<p><img alt="Screenshot" src="../img/Picture3.png" /></p>
<p>Here we can see that the two host VPCs have a /16 address block associated with them.</p>
<h1 id="step-1-review-viptela-sd-wan-api-documentation">Step 1: Review Viptela SD-WAN API documentation</h1>
<p>https://developer.cisco.com/docs/sdwan/</p>
<!-- need to make this hyperlink -->

<p>Most of the APIs used in this document in the 'multicloud' section.  Before we can leverage ANY of the APIs we need to dig into the authentication section of the API documentation.  REMINDER: </p>
<p>Every data service API request begins with the following Base URI.
https://<vmanage-server>/dataservice</p>
<h1 id="step-2-understand-the-cloud-onramp-for-multicloud-process">Step 2: Understand the Cloud OnRamp for Multicloud Process</h1>
<p>A.  Associate Cloud account (see variable file that you’ve updated)
B.  Cloud Global Settings
C.  Create cloud gateway
D.  Manage intent (via segmentation policies)</p>
<h1 id="step-3a-associate-cloud-account">Step 3A: Associate Cloud Account</h1>
<p>(Don’t configure this via the GUI, just showing it for visibility)</p>
<p><img alt="Screenshot" src="../img/Picture4.png" /><br />
<img alt="Screenshot" src="../img/Picture5.png" /><br />
<img alt="Screenshot" src="../img/Picture6.png" /></p>
<p>You can see here that the /Multicloud/accounts API is used to associate the cloud account.  You can create and manage cloud accounts and configure global settings in Cisco vManage for AWS automation. You can create multiple accounts, pick a specific account for transit gateway, mark one or more accounts for transit VPC automation and use other accounts for host VPC discovery and connectivity.  </p>
<p>The multicloud dashboard supports AWS key and IAM role models for authentication. IAM roles only work for AWS cloud deployed Cisco vManage, as this requires special AWS AssumeRole functions.  The cloudGatewayEnabled variable enables the account to deploy the cloud gateway solution (C8000v in the transit VPC + TGW).   </p>
<h1 id="step-3b-cloud-global-settings">Step 3B: Cloud Global Settings</h1>
<p>Global settings enables you to set a configuration one time and repeat across regions and handle resource management globally (per cloud). The software image and instance size specified are used for instantiation of CSRs in the cloud as part of the cloud gateway.  </p>
<p>Global settings include:  </p>
<p>Software image: CSR software image used for creating cloud gateway.  There are two available software types: BYOL (Bring your own license) or PAYG (Pay as you go).  In today’s lab we’ll be using a BYOL image.  Specifically, 17.09.02a will be the software image used. </p>
<p>AWS Instance Size: CSR instance size used depending upon bandwidth requirements.  </p>
<p>Cloud Gateway Solution: The gateway solution used for AWS cloud. For example, transit gateway with transit VPC.  </p>
<p>IP subnet pool: IP subnet pool used for transit VPC creation across regions. Subnet pool can be customized per cloud gateway using custom settings option, if desired. </p>
<p>Intra-Tag Communication: Allows or denies communication between the VPCs under the same tag.  </p>
<p>Default Route in Host VPCs: Default routes are automatically added to the main route table of the VPC that points to the transit gateway.  </p>
<p>Full Mesh of Transit VPCs: Setup a full mesh connectivity between TVPCs of cloud gateways in different regions so as to carry site to site traffic (through CSRs) over public cloud backbone.  </p>
<p>Site-to-Site Tunnel Encapsulation Type: The two options are GRE or IPsec  </p>
<p><img alt="Screenshot" src="../img/Picture7.png" />  </p>
<p>Note: The above image depicts the Transit Gateway – VPN based (using TVPC) against Transit Gateway – Connect Based (using TVPC) options.
What’s the difference?  One has IPsec and one has GRE?   As mentioned in the image above, the connect option is the latest capability available (~2 years old).  The choice for IPSec or GRE tunnels depends on customer requirements such as required bandwidth, security, use of public or private IP addresses for the tunnel endpoints.  Regardless, both options allow the SD-WAN to be extended into the transit VPC.  </p>
<p><img alt="Screenshot" src="../img/Picture8.png" /> 
<img alt="Screenshot" src="../img/Picture9.png" /> </p>
<p>Note: As you can see, the softwareImageId is 17.05.01a-[product ID].  We’ll use ‘Cisco-C8K-17.09.02a-42cb6e93-8d9d-490b-a73c-e3e56077ffd1’ in our request.  Why?  AMI version cannot exceed the vManage version.  Since we’re running 20.9 version of vManage in today’s lab, we’re going to use the 17.09.02a version.    </p>
<p>For today’s lab, we’ll also be using the Transit Gateway – VPN based (using TVPC) cloud gateway solution.</p>
<h1 id="step-3c-create-cloud-gateway">Step 3C: Create cloud gateway</h1>
<p>AKA, where the magic happens!
This is the step where the TGW &amp; Transit VPC (C8000v devices) are deployed!
What do we need to do in preparation for this step?
1.  Log into your AWS console
2.  Go to the AWS Marketplace</p>
<p><img alt="Screenshot" src="../img/Picture10.png" /> </p>
<ol>
<li>Search for ‘8000v’</li>
</ol>
<p><img alt="Screenshot" src="../img/Picture11.png" /> </p>
<ol>
<li>In this lab setup this has already been performed, but a new deployment would require subscribing.  </li>
</ol>
<p><img alt="Screenshot" src="../img/Picture12.png" /> 
<img alt="Screenshot" src="../img/Picture13.png" /> </p>
<p>Note: Take note that running EC2/infrastructure cost of running the VMs are NOT free.  Also, the costs differ depending on the selected region.  Select US West and then US East to compare the pricing differences.</p>
<ol>
<li>Validate permissions-In this lab setup this won’t be an issue, but normal local administrator rights are insufficient.  We specifically need the AmazonEC2FullAccess &amp; AmazonVPCFullAccess permissions associated with the account you supplied on step 6A for the automation deployment to be successful.  </li>
</ol>
<p><img alt="Screenshot" src="../img/Picture14.png" /> </p>
<p>Note: This is a user group called Admins that we’ve associated the privileges to.  You may not have access to IAM as part of this lab but see the above image for demonstration purposes.  Reminder, this is not necessarily a best practice, and you should be following a practice of least privilege and it is common to associate an account specifically for AWS&lt;&gt;vManage interconnect.</p>
<p><img alt="Screenshot" src="../img/Picture15.png" /> </p>
<p>Reviewing the screenshot above, we’re going to ignore the settings section as these configurations are already present in our global config.  This settings section is meant to override the global settings, should that be required.  </p>
<p>There is a field that we must populate, the UUID section, which will specify WHICH virtual devices we intent to deploy.  </p>
<p><img alt="Screenshot" src="../img/Picture16.png" /> </p>
<ol>
<li>Navigate to Configuration&gt;Devices</li>
<li>
<p>You can see a number of devices with ‘Chassis Number’ in the first column-these are the UUIDs.  Copy/paste two UUIDs into your notepad for the deployment section.  </p>
</li>
<li>
<p>Navigate to Configuration&gt;Templates</p>
</li>
</ol>
<p><img alt="Screenshot" src="../img/Picture17.png" /> </p>
<ol>
<li>Navigate to “Device Templates” and take note of the “AWS-cat8kv-multicloud” template.  A normal practice would be to click ‘attach devices’-we’re going to use Ansible for this.  </li>
</ol>
<p><img alt="Screenshot" src="../img/Picture18.png" /> </p>
<ol>
<li>This template will attach when the device comes online (when we configure the step within the OnRamp for Multicloud Create Cloud Gateway step)</li>
</ol>
<p><img alt="Screenshot" src="../img/Picture19.png" /> </p>
<h1 id="step-3d-manage-intent-via-segmentation-policies">Step 3D: Manage intent (via segmentation policies)</h1>
<p>What?  If I keep saying ‘This is where the magic happens’  .. This is where MORE magic happens!  This is where we specifically define which SD-WAN VPNs can reach which AWS VPCs!  Also, we can specify which VPC to VPC traffic we wish to permit.</p>
<p><img alt="Screenshot" src="../img/Picture20.png" /> </p>
<p>Within the GUI, this is a lot prettier and easier to understand.</p>
<p><img alt="Screenshot" src="../img/Picture21.png" /> </p>
<p>Note: Here you can see that VPN65530 can access the 5StarLab VPC &amp; VPN10 can access the test VPC (bidirectionally).  VPN 10 CANNOT access the 5StarLab VPC.  </p>
<p>Now that we understand the steps, reviewed what variables are needed, and have prepared our AWS environment, we’re ready to get into Ansible!</p>
<h1 id="step-4-deployment">Step 4: Deployment</h1>
<p>We’re going to be creating multiple ansible playbooks.  Each playbook will perform a step in the process.  You’ll see the syntax for each of the playbooks have a similar beginning:   </p>
<p>•   Hosts: Uses the host file to determine where to run the play against.  We only have the IP address associated with vManage there.  </p>
<p>•   Gather_facts: This is time saving step.  We do not need to gather any information on the hosts in which the plays are run against so we skip those.  </p>
<p>•   Connection: A normal Ansible play would use SSH and deploy a python script onto the host to execute.  Since we are executing this on the Ansible control node we need to specify local.  </p>
<p>•   Vars_files: In this space we must associate our pod specifics.  Any variables unique to a pod will go here!    </p>
<p>•   Get Cookie task: Before we can use any of the vManage APIs we first need to request a cookie (supplying the username/password).  We’ll use this cookie as a header in the subsequent API requests.  </p>
<p>•   Get XSRF token task: Like the cookie, we’ll need an XSRF token, or cross-site request forgery prevention token, which is required for most POST operations.  This will also be used as a header in the POST requests.   </p>
<p>•   The ‘register’ keyword stores the value of the specific task to be used in later tasks.  Since registered variables are stored in memory, it’s not possible to use them in future plays, and they are only available for the current playbook run.  </p>
<h2 id="associate-cloud-account">Associate Cloud account</h2>
<pre><code>- name: Step 1; Apply AWS credentials
hosts: vmanage
gather_facts: no
connection: local
#ALL YOUR POD/AWS SPECIFICS GO HERE#
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
tasks:
- name: Get Cookies
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/j_security_check
    method: POST
    body_format: form-urlencoded
    validate_certs: False
    body:
        j_username: "{{ USERNAME }}"
        j_password: "{{ PASSWORD }}"
    register: login
- name: Output Cookie Info
    ansible.builtin.debug:
    var: login.cookies
- name: Get XSRF
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/client/token
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
    register: cookie_output
- name: Cookie Output
    ansible.builtin.debug:
    var: cookie_output.content
###########################################################################
- name: Apply info
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/accounts
    method: POST
    body_format: json
    body: "{\"cloudType\":\"AWS\",\"accountName\":\"{{AWS_Account_Name}}\",\"description\":\"{{Description}}\",\"awsKeyCredentials\":{\"apiKey\":\"{{AWS_Access_KEY}}\",\"secretKey\":\"{{AWS_Secret_KEY}}\"},\"cloudGatewayEnabled\":\"tru
e\"}"
    validate_certs: false
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
</code></pre>
<p>We can save this file and run it to validate that there are no issues found.  The syntax to run the playbook is ‘ansible-playbook <file.yaml>’.  If we run the playbook as-is we should see something like the following:</p>
<p><img alt="Screenshot" src="../img/Picture22.png" /> </p>
<p>(Sorry for the small text, but green is good)</p>
<p>What we can see here is that we’re making a POST method call, with our cookie and XSRF token from earlier with a bunch of mess in the body format.  This is a JSON text string of the following:</p>
<pre><code>{
    "cloudType": "AWS",
    "accountName": "&lt;whatever you have in your variable file&gt;",
    "description": "&lt;whatever you have in your variable file&gt;",
    "awsKeyCredentials": {
    "apiKey": "&lt;whatever you have in your variable file&gt;",
    "secretKey": "&lt;whatever you have in your variable file&gt;"
    },
    "cloudGatewayEnabled": "true"
}
</code></pre>
<p>Note: We’re lazy.  You can use a JSON to text string formatter online.  Copy/paste from the API documentation and then modify the values.
We can confirm in the GUI if the account settings have been applied.  </p>
<p><img alt="Screenshot" src="../img/Picture23.png" /></p>
<p>Again, sorry for the small text, but validate in the Cloud Account Management section-it may require a refresh</p>
<h2 id="cloud-global-settings">Cloud global settings</h2>
<p>Note: Understanding the product ID will be required for the global settings API.  </p>
<pre><code>- name: Step 2; Apply Global Settings
hosts: vmanage
gather_facts: no
connection: local
#ALL YOUR POD/AWS SPECIFICS GO HERE#
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
tasks:
- name: Get Cookies
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/j_security_check
    method: POST
    body_format: form-urlencoded
    validate_certs: False
    body:
        j_username: "{{ USERNAME }}"
        j_password: "{{ PASSWORD }}"
    register: login
- name: Output Cookie Info
    ansible.builtin.debug:
    var: login.cookies
- name: Get XSRF
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/client/token
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
    register: cookie_output
- name: Cookie Output
    ansible.builtin.debug:
    var: cookie_output.content
##################################################################################
- name: Apply Global Settings
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/settings/global
    method: POST
    body_format: json
    body: "{\"cloudGatewaySolution\":\"tgw_tvpc\",\"cloudType\":\"AWS\",\"name\":\"{{AWS_Account_Name}}\",\"enableAutoCorrect\":true,\"enablePeriodicAudit\":true,\"softwareImageId\":\"Cisco-C8K-17.09.02a-42cb6e93-8d9d-490b-a73c-e3e56077ffd1\",\"instanceSize\":\"t3.medium\",\"intraTagComm\":true,\"ipSubnetPool\":\"192.168.100.0/24\",\"accountId\":\"{{AWS_Account_ID}}\",\"cgwBgpAsnOffset\":64520,\"mapTvpc\":true,\"programDefaultRoute\":true,\"region\":\"us-east-1\",\"tunnelType\":\"ipsec\"}"
    validate_certs: false
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
</code></pre>
<p>Did we see all green?  Verify in the vManage GUI global settings section!  </p>
<p><img alt="Screenshot" src="../img/Picture24.png" />  </p>
<h2 id="discover-host-private-networks">Discover Host Private Networks</h2>
<pre><code>- name: Step 3; Discover AWS Host VPCs
hosts: vmanage
gather_facts: no
connection: local
#ALL YOUR POD/AWS SPECIFICS GO HERE#
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
tasks:
- name: Get Cookies
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/j_security_check
    method: POST
    body_format: form-urlencoded
    validate_certs: False
    body:
        j_username: "{{ USERNAME }}"
        j_password: "{{ PASSWORD }}"
    register: login
- name: Output Cookie Info
    ansible.builtin.debug:
    var: login.cookies
- name: Get XSRF
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/client/token
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
    register: cookie_output
- name: Cookie Output
    ansible.builtin.debug:
    var: cookie_output.content
##################################################################################
- name: Get Host VPCs
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/hostvpc?cloudType=AWS
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
    register: VPC
- name: Output VPCs
    ansible.builtin.debug:
    var: VPC.json.data
- name: Save
    ansible.builtin.copy:
    content: "{{ VPC.json.data }}"
    dest: /home/dcloud/python-viptela/dest_file.json
</code></pre>
<p><img alt="Screenshot" src="../img/Picture25.png" />  </p>
<p>Note: Take the VPC IDs and add the values to your external_vars file.  </p>
<p><img alt="Screenshot" src="../img/Picture26.png" />   </p>
<p>Verifying in the GUI, we should see the same output.  </p>
<h2 id="tag-aws-host-vpcs">Tag AWS Host VPCs</h2>
<pre><code>- name: Step 4; Tag AWS Host VPCs
hosts: vmanage
gather_facts: no
connection: local
#ALL YOUR POD/AWS SPECIFICS GO HERE#
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
vars:
    jsondata: "{{ lookup('file', 'dest_file.json') | from_json }}"
tasks:
- name: Get Cookies
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/j_security_check
    method: POST
    body_format: form-urlencoded
    validate_certs: False
    body:
        j_username: "{{ USERNAME }}"
        j_password: "{{ PASSWORD }}"
    register: login
- name: Output Cookie Info
    ansible.builtin.debug:
    var: login.cookies
- name: Get XSRF
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/client/token
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
    register: cookie_output
- name: Cookie Output
    ansible.builtin.debug:
    var: cookie_output.content
###########################################################################
- name: RED VPC
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/hostvpc/tags?cloudType=AWS
    method: POST
    body_format: json
    body: "{\"tagName\":\"Red\",\"interconnectTag\":false,\"hostVpcs\":[{\"accountId\":\"{{ AWS_Account_ID }}\",\"accountName\":\"{{ AWS_Account_Name }}\",\"region\":\"us-east-1\",\"cloudType\":\"AWS\",\"hostVpcId\":\"{{Host_VPC_1_ID}}
\",\"hostVpcName\":\"test-vpc-1\"}]}"
    validate_certs: false
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
- name: Print
    ansible.builtin.debug:
    msg: "VPC {{Host_VPC_1_ID}} given the tag of Red"
- name: Sleep for 15 seconds and continue with play
    ansible.builtin.wait_for:
    timeout: 15
    delegate_to: localhost
- name: BLUE VPC
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/hostvpc/tags?cloudType=AWS
    method: POST
    body_format: json
    body: "{\"tagName\":\"Blue\",\"interconnectTag\":false,\"hostVpcs\":[{\"accountId\":\"{{ AWS_Account_ID }}\",\"accountName\":\"{{ AWS_Account_Name }}\",\"region\":\"us-east-1\",\"cloudType\":\"AWS\",\"hostVpcId\":\"{{Host_VPC_2_ID}
}\",\"hostVpcName\":\"test-vpc-2\"}]}"
    validate_certs: false
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
- name: Print
    ansible.builtin.debug:
    msg: "VPC {{Host_VPC_2_ID}} given the tag of Blue"
</code></pre>
<p><img alt="Screenshot" src="../img/Picture27.png" /> 
<img alt="Screenshot" src="../img/Picture28.png" />  </p>
<p>Note: One thing you may note is the ansible.builtin.wait_for module.  This is a module to delay the subsequent task for a defined amount of time.  We’ve specified a wait of 15 seconds as you’d otherwise get an error trying to apply the Blue tag until the Red tag application is complete.  </p>
<p><img alt="Screenshot" src="../img/Picture29.png" /></p>
<h2 id="create-cloud-gateway">Create Cloud Gateway</h2>
<p>Note: This step takes a few minutes to deploy.<br />
Before we can deploy our cloud routers, we first need to associate a template.  We’ll be using the default device template ‘AWS-cat8kv-multicloud.’  As mentioned in the section prior, this is done in the GUI at Configuration&gt;Templates&gt;Device Templates.  </p>
<p>But…we’re doing this in ansible.  Recall task 8 from scenario 1-we’re going to use the same role.  We have a playbook called ‘5a_Attach_AWS_Template.yml’ which should look very similar to ‘19_Attach_Device_Template.yml.’  The main difference being the addition of another variable: “/0/GigabitEthernet2//interface/tunnel-interface/color/value: default”</p>
<pre><code>- name: Attach AWS Device Template
hosts: all
connection: local
gather_facts: no
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
roles:
    -  role: login
    tags: CL-2001,CL-2001:login
    -  role: attach_device_template
    tags: lab2:attach
    vars:
        DeviceTemplateList:
            AWS-cat8kv-multicloud:
            - csv-deviceIP: "-"
                csv-status: "complete"
                csv-deviceId:  "{{ UUID_1 }}"
                csv-host-name: "-"
                //system/host-name: "AWS1"
                //system/site-id: "5"
                //system/system-ip: "2.2.2.1"
                /0/GigabitEthernet2//interface/tunnel-interface/color/value: "default"
            - csv-deviceIP: "-"
                csv-status: "complete"
                csv-deviceId:  "{{ UUID_2 }}"
                csv-host-name: "-"
                //system/host-name: "AWS2"
                //system/site-id: "5"
                //system/system-ip: "2.2.2.2"
                /0/GigabitEthernet2//interface/tunnel-interface/color/value: "default"
</code></pre>
<p>Note: In this example we’re going to reference the external_vars.yml file to use the pod-specific UUIDs. </p>
<p>Execute this playbook.  </p>
<pre><code>- name: Step 5; Create Cloud Gateway
hosts: vmanage
gather_facts: no
connection: local
#ALL YOUR POD/AWS SPECIFICS GO HERE#
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
vars:
    jsondata: "{{ lookup('file', 'dest_file.json') | from_json }}"
tasks:
- name: Get Cookies
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/j_security_check
    method: POST
    body_format: form-urlencoded
    validate_certs: False
    body:
        j_username: "{{ USERNAME }}"
        j_password: "{{ PASSWORD }}"
    register: login
- name: Output Cookie Info
    ansible.builtin.debug:
    var: login.cookies
- name: Get XSRF
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/client/token
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
    register: cookie_output
- name: Cookie Output
    ansible.builtin.debug:
    var: cookie_output.content
##################################################################################
- name: Deploy CGW
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/cloudgateway
    method: POST
    body_format: json
    validate_certs: False
    body: "{\"accountId\":\"{{AWS_Account_ID}}\",\"cloudType\":\"AWS\",\"region\":\"us-east-1\",\"cloudGatewayName\":\"CL2023_CGW\",\"devices\":[\"{{UUID_1}}\",\"{{UUID_2}}\"],\"description\":\"\"}"
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
    register: results
</code></pre>
<p>Configuration&gt;Templates</p>
<p><img alt="Screenshot" src="../img/Picture30.png" /></p>
<p>Note: We can see here that the two cloud routers have the AWS template assigned (attached).  </p>
<h2 id="manage-intent">Manage Intent</h2>
<pre><code>- name: Step 6; Manage Intent
hosts: vmanage
gather_facts: no
connection: local
#ALL YOUR POD/AWS SPECIFICS GO HERE#
vars_files:
- /home/dcloud/python-viptela/external_vars.yml
vars:
    jsondata: "{{ lookup('file', 'dest_file.json') | from_json }}"
tasks:
- name: Get Cookies
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/j_security_check
    method: POST
    body_format: form-urlencoded
    validate_certs: False
    body:
        j_username: "{{ USERNAME }}"
        j_password: "{{ PASSWORD }}"
    register: login
- name: Output Cookie Info
    ansible.builtin.debug:
    var: login.cookies
- name: Get XSRF
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/client/token
    method: GET
    body_format: json
    validate_certs: False
    return_content: true
    headers:
        Cookie: "{{ login.cookies_string }}"
    register: cookie_output
- name: Cookie Output
    ansible.builtin.debug:
    var: cookie_output.content
##################################################################################
- name: Manage Intent
    ansible.builtin.uri:
    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/map?cloudType=AWS
    method: POST
    body_format: json
    validate_certs: False
    body: "{\"cloudType\":\"AWS\",\"connMatrix\":[{\"srcType\":\"vpn\",\"srcId\":\"10\",\"conn\":\"enabled\",\"destId\":\"Red\",\"destType\":\"tag\"},{\"srcType\":\"tag\",\"srcId\":\"Red\",\"conn\":\"enabled\",\"destId\":\"10\",\"destT
ype\":\"vpn\"}]}"
    headers:
        Cookie: "{{ login.cookies_string }}"
        X-XSRF-TOKEN:  "{{ cookie_output.content }}"
</code></pre>
<p><img alt="Screenshot" src="../img/Picture31.png" /></p>
<p>Note: AWS cloud operations can take up to 40-60 mins to complete mapping the intent management.  In our experience testing this lab, it takes around 5-10 minutes to get to an ‘all green’ state:  </p>
<p><img alt="Screenshot" src="../img/Picture32.png" /></p>
<p><img alt="Screenshot" src="../img/Picture33.png" /></p>
<p>Once you see all green it indicates the TVPC C8000vs are reachable and that there are IPsec tunnels established to the TGW.  Proceed to validation.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../about/" class="btn btn-neutral float-left" title="About This Lab"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../sc_2_validation/" class="btn btn-neutral float-right" title="Validation">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../about/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../sc_2_validation/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
