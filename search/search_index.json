{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Extend the Enterprise WAN to the AWS Cloud: A first-hand deployment experience using Ansible","text":"<p>LTRXAR-2001</p>"},{"location":"#speakers","title":"Speakers","text":"<p>Kyle Barnes \u2013 CX Architect, Praveen Poojary \u2013 CX Architect, Navin Suvarna \u2013 CX Architect</p>"},{"location":"#about-this-lab","title":"About this lab","text":""},{"location":"#lab-introduction","title":"Lab Introduction","text":"<p>We\u2019d like to introduce you to a simple SD-WAN deployment: One single border router.  In this lab the Viptela vManage, vSmart, vBond, and border router bring up sequence has already been completed. We have two hosts, a windows jumpbox and a linux host, that we\u2019ll leverage to provision our AWS account and execute our Ansible playbooks, respectively.  We\u2019ve already deployed Ansible on the Linux host so we\u2019re ready to dive into two very unique scenarios.  </p>"},{"location":"#lab-flow","title":"Lab Flow","text":"<p>In this lab, you will follow the lab guide on the scenarios below: Scenario 1: We\u2019ll explore the topics of Viptela device vs feature templates, Explore Ansible roles, Jinja2 templates, modules, etc.  We\u2019ll then leverage existing templates to reverse engineer the template structure to create our own! Scenario 2: Here we\u2019ll leverage a lab AWS environment to deploy Viptela\u2019s Cloud OnRamp for Multicloud using Ansible playbooks.  While most (all) of the playbooks used in this section are URI post/get calls, the outcome of this scenario is a deeper understanding of the APIs/Config Options available &amp; used during the OnRamp process.</p>"},{"location":"#lab-access","title":"Lab Access","text":"<p>Below table provides the IP addresses and credentials for the devices used in this lab: Note: You are able to access all devices via SSH and GUI after AnyConnect into dCloud. There is no remote desktop or any jump server required to access the lab. If you don't have AnyConnect VPN Client installed, you can download AnyConnect from here  https://developer.cisco.com/site/devnet/sandbox/anyconnect/</p>"},{"location":"#lab-topology","title":"Lab Topology","text":"<p>(Remember when we said \u201cVERY small SD-WAN deployment?) </p>"},{"location":"#learning-objectives","title":"Learning Objectives","text":"<p>Upon completion of this lab, you will be able to understand the following: \u2022   Viptela SD-WAN device vs feature templates \u2022   Understand basic Ansible structure (playbooks, roles, variables, modules) \u2022   Available Cisco Viptela Modules \u2022   Ansible installation process \u2022   Viptela SD-WAN API documentation \u2022   Viptela Cloud OnRamp process \u2022   Viptela Cloud OnRamp APIs  </p> <p>Cisco SD-WAN includes a useful tool for configuration management and network monitoring: vManage. Within the SD-WAN fabric, the vManage tool is responsible for handling the management plane, meaning that all the configurations can be performed from its graphical user interface (GUI). The vManage tool also offers a rich set of REST APIs, enabling you to automate specific workflows using your favorite tool, such as Postman, Python, Ansible, and others.</p>"},{"location":"#task-1-environment-setup","title":"Task 1: Environment Setup","text":"<ol> <li>Create a notepad that will have the following information that you\u2019ll be working to fill out throughout this lab. vManage IP: vManage Username: vManage Password: AWS Access Key: AWS Secret Key: 8000v UUID1: (To be used for Scenario 2) 8000v UUID2: (To be used for Scenario 2) 8000v UUID3: (To be used for Scenario 1) VPC 1 ID:  VPC 2 ID:</li> <li>Connect to the Ubuntu host via the VM console (or PuTTY).  </li> <li> <p>Review the Cisco Viptela vManage Python SDK/CLI/Ansible repo in the /home/dcloud directory. Note: This has already been installed, but the process of installation was simple</p> <p><code>cd home/dcloud pip install viptela</code></p> </li> <li> <p>Navigate to the python-viptela directory</p> </li> <li>Verify Ansible is installed with ansible \u2013version </li> <li>Modify the hosts file.  The default location for this file is /etc/ansible/hosts. [vmanage]  Note: This is as bare-bones as one could possibly create a host file.  For the purpose of education, the host file format is most commonly in either  INI or YAML.  This host file allows Ansible playbooks to be executed hierarchically, with nested parent/child groups, and with specific variables associated to a host or group(s) of hosts. <pre><code>[webservers]\nfoo.example.com\nbar.example.com\n\n[dbservers]\none.example.com\ntwo.example.com\nthree.example.com\n</code></pre> <ol> <li> <p>Open your windows jumphost via remote desktop  </p> </li> <li> <p>Provision AWS credentials</p> </li> </ol> <p></p> <p>(Double-click the Launch shortcut)</p> <ol> <li>Request AWS account (this takes a couple of minutes, so let\u2019s get this knocked out) </li> </ol>"},{"location":"#introduction-to-key-concepts","title":"Introduction to key concepts","text":"<p>In the SD-WAN environment, you must still manage configuration of devices (vEdges) independently. This is because the SD-WAN fabric is widely distributed in the wide-area network (WAN). The vManage is a single point of configuration for the whole WAN fabric and uses a templates to simplify configuration management. In SD-WAN, you can configure every feature with a feature template. Templates ensure that the configuration is consistent across all the devices. Feature templates are grouped together into device templates that will be attached to the end devices. What is a feature template? Feature templates are the building blocks of complete configuration for a device. For each feature that you can enable on a device, Cisco vManage provides a template form that you fill out. The form allows you to set the values for all configurable parameters for that feature. Because device configurations vary for different device types and the different types of routers, feature templates are specific to the type of device.  How does this differ from device templates? Device templates use feature templates!  Device templates contain complete operational configuration for a device. You create device templates by consolidating individual feature templates.  Each device template is specific for a type of device. For each device type, if multiple devices have the same configuration, you can use the same device template for them. For example, many of the routers in a network might have the same basic configuration, so you can configure them with the same templates. (You specify the differences in the templates using configuration variables, which are discussed below.) If the configurations for the same type of devices are different, you create separate device templates. For the first scenario, we\u2019ll be creating &amp; using several Ansible playbooks.  The purpose of this scenario is to familiarize yourself with the YAML playbook syntax and to better understand feature and device templates within an SD-WAN fabric. One thing you\u2019ll find throughout these subsequent tasks are a few Ansible playbooks that leverage vManage modules within Ansible found here https://github.com/CiscoDevNet/python-viptela What are modules? \u201cAnsible modules are units of code that can control system resources or execute system commands. Ansible provides a module library that you can execute directly on remote hosts or through playbooks.\u201d  In other words, modules are Python scripts that expect several inputs and can provide varying outputs.  </p>"},{"location":"#template-export-demonstration","title":"Template Export (demonstration)","text":"<p>The first playbook we\u2019ll create uses the ansible URI module to invoke an API call to vManage. The main API used here is the /dataservice/template/feature API. The /dataservice/ part of the URL represents the API entry point. The remainder, /template/feature/, identifies the resource that you are going to manipulate: in this case, feature templates. The methods that you are going to use to manipulate feature template are: GET: Retrieves information from the system. POST: Creates a new object (in this case, a new feature template). PUT: Modifies an existing object. DELETE: Deletes an existing object</p> <p>The default output is a JSON formatted list of the various device templates, and the template ID associated with each individual feature template. Note: The template ID will be used to uniquely identify the feature templates when we associate the feature templates with the device template at a later step </p> <p>The playbook then cycles through the json data and combines the feature template name &amp; feature template ID into a key/value pair.  These values are stored into a local variable called feature_template_db which is then printed.  </p> <pre><code>- name: Export vManage Template\n  hosts: vmanage\n  gather_facts: no\n  connection: local\n  vars:\n    file: vmanage-templates.yml\n  #ALL YOUR POD/AWS SPECIFICS GO HERE#\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  tasks:\n  - name: Get Cookies\n    ansible.builtin.uri:\n      url: https://{{ VMANAGE_IP }}/j_security_check\n      method: POST\n      body_format: form-urlencoded\n      validate_certs: False\n      body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n  - name: Output Cookie Info\n    ansible.builtin.debug:\n      var: login.cookies\n  - name: Get XSRF\n    ansible.builtin.uri:\n      url: https://{{ VMANAGE_IP }}/dataservice/client/token\n      method: GET\n      body_format: json\n      validate_certs: False\n      return_content: true\n      headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n  - name: Cookie Output\n    ansible.builtin.debug:\n      var: cookie_output.content\n##################################################################################\n  - name: Get Feature Template\n    uri:\n      url: https://{{ VMANAGE_IP }}/dataservice/template/feature\n      method: GET\n      return_content: yes\n      validate_certs: no\n      headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n        Content-Type: \"application/json\"\n    register: template_list\n  - set_fact:\n      feature_template_db: \"{{ feature_template_db|default({}) | combine( {item.templateName: item.templateId } ) }}\"\n    no_log: True\n    with_items: \"{{ template_list.json.data }}\"\n\n  - debug:\n      msg: \"{{ feature_template_db }}\"\n</code></pre> <p>Copy/paste this into a new yml file called \u201c10_Export_Feature_Templates.yml\u201d \u2013 this playbook will only be run for demonstration purposes and is not used in the subsequent sections.</p> <p></p> <p>But wait?  What is the mess above the \u201c****\u201d line in playbook 10?  You\u2019ll see this in differing flavours throughout this lab guide but the principal behind this is that before we can do anything using APIs we need to 1) authenticate (get a cookie) and 2) generate an XSRF token, using the cookie.  Between scenario 1 and 2 you\u2019ll see this done in varying ways-using a role and/or part of the Ansible playbook.  The former option allows for cleaner, more concise Ansible playbook construction.  Regardless, URI calls to the vManage APIs are how we perform most (all) of the steps throughout this lab guide.  This isn\u2019t always how Ansible is used, though.  Executing these plays locally on the Ansible control node is being performed with the \u201cConnection: local\u201d syntax as the top of the Playbook.  Ansible typically works by connecting to your nodes and pushing out small programs\u2014called modules\u2014to these nodes. Modules are used to accomplish automation tasks in Ansible. These programs are written to be resource models of the desired state of the system. Ansible then executes these modules and removes them when finished.  For automating network devices and other IT appliances where modules cannot be executed, Ansible will run on the control node (i.e. what we\u2019re doing for all of our Ansible plays).  </p>"},{"location":"#template-export-template-dump","title":"Template Export (template dump)","text":"<p>Copy and paste the following into a new yml file called \u201c11_Export_Existing_Templates.yml\u201d The purpose of this playbook is to use the the vmanage_template_export API (which should be visible within the python-viptela&gt;ansible&gt;modules directory within the github link).  The contents of this export are stored in the yml file \u2018vmanage-templates.yml.\u2019  We\u2019ll leverage this \u2018dump\u2019 of feature templates in subsequent steps throughout Scenario 1.  But how? Before we get to that, execute the playbook and review the output of the vmanage-templates.yml file (created in the same directory as where the playbook is executed).  </p> <pre><code>- name: Export vManage Template\n  hosts: vmanage\n  gather_facts: no\n  connection: local\n  vars:\n    file: vmanage-templates.yml\n  #ALL YOUR POD/AWS SPECIFICS GO HERE#\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  tasks:\n  - name: Get Cookies\n    ansible.builtin.uri:\n      url: https://{{ VMANAGE_IP }}/j_security_check\n      method: POST\n      body_format: form-urlencoded\n      validate_certs: False\n      body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n  - name: Output Cookie Info\n    ansible.builtin.debug:\n      var: login.cookies\n  - name: Get XSRF\n    ansible.builtin.uri:\n      url: https://{{ VMANAGE_IP }}/dataservice/client/token\n      method: GET\n      body_format: json\n      validate_certs: False\n      return_content: true\n      headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n  - name: Cookie Output\n    ansible.builtin.debug:\n      var: cookie_output.content\n##################################################################################\n  tasks:\n    - vmanage_template_export:\n        user: \"{{ USERNAME }}\"\n        host: \"{{ VMANAGE_IP }}\"\n        password: \"{{ PASSWORD }}\"\n        file: \"{{ file }}\"\n</code></pre> <p></p> <p>Now that we have this information available to us, we can effectively reverse engineer the existing templates to create a new device template of our own.  </p> <p>How?</p> <p>Before we answer how let\u2019s cover two topics: Roles: A role in Ansible is a set of tasks that accomplish a specific goal within a playbook. Roles let you automatically load related vars, files, tasks, handlers, and other Ansible artifacts based on a known file structure. After you group your content in roles, you can easily reuse them and share them with other users. Jinja2: Jinja2 templates are simple template files that store variables that can change from time to time. When Playbooks are executed, these variables get replaced by actual values defined in Ansible Playbooks.  </p> <p>Here is a high-level flow as to how we\u2019ll leverage Jinja2 templates &amp; roles to develop our own device templates using Ansible. 1.  Create roles via  Ansible Galaxy: \u201cansible-galaxy init ~/python-viptela/roles/\u201d  This creates a directory that we can populate that we can subsequently call across other playbooks. Note: see the roles directory 2.  Identify what part do we want to work on (use VPN0 as an example) 3.  Create the j2 file from the vmanage-templates.yml blueprint (free online YML to j2 converters exist) using the portion we intend to modify (in step 2). 4.  Modify j2 components that we intend to templatize. Note: We selected some things to demonstrate the key/value pair, but one could modify this with whatever factors you care to templatize.  <ol> <li>Create subsequent playbooks that call the role where the J2 file resides and pass the specific variables.  </li> <li>The role will use the tasks main.yml file in a top-down format (render first, post second) </li> </ol> <p>a.  Render: Create the JSON payload from the variables that are passed when the role is used </p> <p>b.  Post: This may be a surprise, but post\u2026performs a URI post using the rendered JSON file. </p> <p>To summarize the high-level components within the roles directories:</p> <p></p> <p>Templates: This is where the actual j2 file lives. Tasks:  Where we render the JSON payload and post when the role is referenced. Files: Latest JSON payload, with passed variables populated.</p> <p>Note: An Ansible role has a defined directory structure with eight main standard directories. You must include at least one of these directories in each role. You can omit any directories the role does not use.</p>"},{"location":"#scenario-1","title":"Scenario 1","text":"<p>As described in the previous section, Configuration management in SD-WAN is performed with Feature and device templates. Think of a feature template as a small piece of a puzzle that describes the configuration of a given feature, such as a Banner, VPN, or BGP. The feature template renders the configuration into the CLI. After you create the feature templates, you can merge them together into a device template. A device template represents a target design of a given branch. For example, you need a device template for single-homed branches, one for dual-homed ones, another for branches that leverage routing protocols, and more. In Section1, you will automatically provision a vEdge. To do that, you need to create a set of feature templates, merge those feature templates into a device template and subsequently attach the device-template to the vEdge.  To begin, you are going to create these feature templates: \u2022   VPN0 Template \u2022   VPN512 Template \u2022   VPN10 Template (Service VPN) \u2022   VPN0 Interface Template \u2022   VPN512 Interface Template \u2022   VPN10 Interface Template (Service VPN)</p>"},{"location":"#task-1-deploy-feature-vpn0-template","title":"Task 1: Deploy Feature VPN0 Template","text":"<p>Using the logic explained in the key concepts introduction, we\u2019re going to develop our own template based on a number of user-defined variables.  In this first feature template example, we \u2018care\u2019 about the following: 1.  Template Name 2.  Template Description 3.  DNS Address 4.  Default next hop 5.  Default next hop Distance Given we know WHAT we want to modify, we now need to create a J2 template (using the vmanage-templates.yml \u2018dump\u2019 created previously).  A J2 template is formatted in JSON so we\u2019ll take the template we which to templatize (VPN0) and convert it into JSON. https://onlineyamltools.com/convert-yaml-to-json</p> <ol> <li>Convert the VPN0 YML content from the vmanage-templates.yml file into JSON, and modify the 5 items listed above.  You\u2019re going to be looking for the \u2018BR1-C8000v-VPN0\u2019 template name. The syntax for the variables is: \"{{ VARIABLE }}\" Find the 5 items we wish to templatize and give them a name.  For this first example, we\u2019ve used the following: \"{{ Template_Name }}\" \"{{ Template_Description }}\" \"{{ DNS_Address }}\" \"{{ Default_Next_Hop_VPN0 }}\" \"{{ Default_Next_Hop_VPN0_Distance }}\"</li> </ol> <p>Now that we have the YML file converted into a JSON and the values replaced with variable names, we need to create our role directory and add this content into the templates subdirectory. 2.  Run the following:</p> <pre><code>ansible-galaxy init ~/python-viptela/roles/&lt;ROLE NAME&gt;\n</code></pre> <ol> <li> <p>Navigate to the new role you\u2019ve defined and go to the templates subdirectory (it is empty).  Create a j2 file (nano .j2) and copy/paste the file you\u2019ve been modifying. Save/exit (Ctrl+X) <li> <p>Now that we have the template we need to tell the role WHAT to do, should the role be called.  Navigate to \u2018tasks.\u2019 We can see that a value already exists here, called main.yml.  Should we have a need for multiple tasks, main.yml is executed sequentially.  If you perform at \u2018more main.yml\u2019 you\u2019ll see that this file is currently empty.  We\u2019ll create two tasks, then reference them within main.yml by importing them. render_vpn0_template.yml post_vpn0_template.yml  </p> </li> <li>Create the following files within the tasks directory. Let\u2019s cover &amp; modify the render_vpn0_template.yml task first. This task does nothing more than create a JSON file from the j2 template that we created previously.  What\u2019s different is that this JSON file will include the values created from any variables passed when this role is called.  </li> <pre><code>- name: Clean Previously Rendered Templates\n  file:\n    path: \"{{item}}\"\n    state: absent\n    force: true\n  with_fileglob:\n    - \"{{role_path}}/files/*\"\n\n- name: Render VPN0 Template\n  template: src=\"&lt;Template Name&gt;\u201d.j2\" dest={{role_path}}/files/{{ Template_Name }}.json\n</code></pre> <p>This file specifically references the j2 template that you\u2019ve created-so make sure you specify the correct name.  It then creates the JSON file in the directory \u2018files\u2019 within this specific role.  Lastly, because this playbook may be run more than once, it replaces any existing files with the newly created one on each playbook execution. 6.  Lets navigate back to the main.yml and import this task:</p> <pre><code>- import_tasks: render_vpn0_template.yml\n</code></pre> <p>Now that we have the task to CREATE the JSON file\u2026we need a task to do a URI POST, using the JSON file created previously within the body of our message. 7.  Create another yml file within the tasks directory, calling this one post_vpn0_template.yml:</p> <pre><code>- name: Post VPN0 Template\n  uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/template/feature\n    method: POST\n    return_content: yes\n    validate_certs: no\n    body: \"{{lookup('file', '{{item}}')}}\"\n    body_format: json\n    headers:\n      Cookie: \"{{ login.cookies_string }}\"\n      X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n      Content-Type: \"application/json\"\n  with_fileglob:\n    - \"{{ role_path }}/files/*.json\"\n</code></pre> <p>Like before, we now need to modify our main.yml file to call the post task. 8.  Add the following to the main.yml file, after the render import:</p> <pre><code>- import_tasks: post_vpn0_template.yml\n</code></pre> <p>If we\u2019ve followed the above steps correctly, our main.yml should look something like this:</p> <pre><code>dcloud@dcloud-virtual-machine:~/python-viptela/roles/create_vpn0_template/tasks$ more main.yml\n- import_tasks: render_vpn0_template.yml\n- import_tasks: post_vpn0_template.yml\n</code></pre> <p>To recap, the above steps: 1.  Created the role 2.  Created the j2 template, from the vmanage-templates.yml \u2018dump\u2019 3.  Created the tasks render &amp; post We are now ready to create a playbook that will leverage the role! 9.  Create a new YML file called \u201c12_Deploy_Feature_VPN0_Template.yml\u201d</p> <pre><code>- name: Deploy Feature VPN0 Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_vpn0_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Template_Name: 'CL-BR-C8000v-VPN0'\n         - Template_Description: 'VPN0 Template for the On-Prem C8000v'\n         - DNS_Address: '198.18.1.1'\n         - Default_Next_Hop_VPN0: '198.19.2.1'\n         - Default_Next_Hop_VPN0_Distance: '1'    \n</code></pre> <p>Hopefully the explanation in the previous steps make this playbook\u2019s purpose obvious, but from a high-level we\u2019re calling the role \u2018login\u2019 to generate a cookie &amp; XSRF token then the role \u2018create_vpn0_template\u2019 and passing a number of variables to the j2 template within that role. 10. Execute this playbook. (If it wasn\u2019t the obvious, you now have a new feature template).</p>"},{"location":"#task-2-deploy-feature-vpn512-template","title":"Task 2: Deploy Feature VPN512 Template","text":"<ol> <li>Do everything you did before, again.  Just kidding, we\u2019ve done the leg work to pre-populate these roles (as you\u2019ve probably seen in the roles directory).  </li> <li>Simply create a new yml file called \u201813_Deploy_Feature_VPN512_Template.yml.\u2019  We\u2019ll use this playbook to-you guessed it-create a VPN512 template.  </li> </ol> <pre><code>- name: Deploy Feature VPN512 Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_vpn512_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Template_Name: 'CL-BR-C8000v-VPN512'\n         - Template_Description: 'VPN512 Template for the On-Prem C8000v'\n         - Default_Next_Hop_VPN512: '198.18.128.1'\n         - Default_Next_Hop_VPN512_Distance: '1'\n</code></pre> <ol> <li>Execute this playbook.  </li> </ol>"},{"location":"#task-3-deploy-service-vpn10-template","title":"Task 3: Deploy Service VPN10 Template","text":"<ol> <li>Create a new yml file called \u201814_Deploy_Feature_Service_VPN10_Template.yml.\u2019</li> </ol> <pre><code>- name: Deploy Service VPN10 Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_service_vpn10_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Template_Name: 'CL-BR-C8000v-VPN10'\n         - Template_Description: 'VPN10 Template for the On-Prem C8000v'\n         - DNS_Address: '198.18.1.1'  \n</code></pre> <ol> <li>Execute this playbook</li> </ol>"},{"location":"#task-4-deploy-vpn0-interface-feature-template","title":"Task 4: Deploy VPN0 Interface Feature Template","text":"<ol> <li>Create a new yml file called \u201815_Deploy_Feature_VPN0_Interface_Template.yml\u2019</li> </ol> <pre><code>- name: Deploy Feature VPN0 Interface Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_vpn0_interface_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Template_Name: 'CL-BR-C8000v-VPN0-INT'\n         - Template_Description: 'VPN0 Interface Template for the On-Prem C8000v'\n         - VPN_Interface: 'GigabitEthernet3'\n         - VPN_Interface_Address: '198.19.2.13/24'\n         - VPN_Interface_IP_MTU: '1500'\n         - VPN_Interface_MTU: '1500'\n         - VPN_Interface_ARP_Timeout: '1200'\n         - VPN_Interface_Load_Interval: '30'\n         - Tunnel_Interface_Color: 'biz-internet'\n         - Tunnel_Interface_Encap: 'ipsec'\n         - Tunnel_DHCP: 'true'\n         - Tunnel_DNS: 'true'\n         - Tunnel_ICMP: 'true'\n         - NAT_UDP_Timeout: '1'\n         - NAT_TCP_Timeout: '60'\n         - NAT_Type: 'interface'\n         - NAT_Overload: 'true'\n</code></pre> <p>Note: While this looks like a lot bigger, it simply references a role (create_vpn0_interface_template) that has more variables specified in its j2 template. 2.  Execute this playbook.  </p>"},{"location":"#task-5-deploy-vpn512-interface-feature-template","title":"Task 5: Deploy VPN512 Interface Feature Template","text":"<ol> <li>Create a new yml file called \u201816_Deploy_Feature_VPN512_Interface_Template.yml\u2019</li> </ol> <pre><code>- name: Deploy Feature VPN512 Interface Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_vpn512_interface_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Template_Name: \u2018CL-BR-C8000v-VPN512-INT\u2019\n         - Template_Description: \u2018VPN512 Interface Template for the On-Prem C8000v\u2019\n         - VPN_Interface: \u2018GigabitEthernet1\u2019\n         - VPN_Interface_Address: \u2018198.18.133.13/18\u2019\n         - VPN_Interface_IP_MTU: \u20181500\u2019\n         - VPN_Interface_MTU: \u20181500\u2019\n         - VPN_Interface_ARP_Timeout: \u20181200\u2019\n         - VPN_Interface_Load_Interval: \u201830\u2019\n</code></pre> <ol> <li>Execute this playbook.  </li> </ol>"},{"location":"#task-6-deploy-vpn10-interface-template-service-vpn","title":"Task 6: Deploy VPN10 Interface Template (Service VPN)","text":"<ol> <li>Create a new yml file called \u201816_Deploy_Feature_VPN512_Interface_Template.yml\u2019</li> </ol> <pre><code>- name: Deploy Feature Service VPN10 Interface Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_service_vpn10_interface_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Template_Name: 'CL-BR-C8000v-VPN10-INT'\n         - Template_Description: 'VPN10 Interface Template for the On-Prem C8000v'\n         - VPN_Interface: 'GigabitEthernet2'\n         - VPN_Interface_Address: '100.64.10.1/24'\n         - VPN_Interface_IP_MTU: '1500'\n         - VPN_Interface_MTU: '1500'\n         - VPN_Interface_ARP_Timeout: '1200'\n         - VPN_Interface_Load_Interval: '30'\n</code></pre> <ol> <li>Execute this playbook.  </li> </ol>"},{"location":"#task-7-deploy-device-template","title":"Task 7: Deploy Device Template","text":"<ol> <li>Create a new yml file called \u201818_Deploy_Device_Template.yml\u2019</li> </ol> <pre><code>- name: Deploy Device Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: create_device_template\n       tags: CL-2001,CL-2001:create\n       vars:\n         - Device_Template_Name: 'CL-BR1-C8000v'\n         - Device_Template_Description: 'Device Template for OnPrem C8000v'\n         - Feature_AAA: Factory_Default_AAA_CISCO_Template\n         - Feature_BFD: Default_BFD_Cisco_V01\n         - Feature_Banner: Factory_Default_Retail_Banner\n         - Feature_Logging: Default_Logging_Cisco_V01\n         - Feature_OMP: Factory_Default_Cisco_OMP_ipv46_Template\n         - Feature_Global: Factory_Default_Global_CISCO_Template\n         - Feature_Security: Default_Security_Cisco_V01\n         - Feature_System: Default_BootStrap_Cisco_System_Template\n         - Feature_VPN:\n            CL-BR-C8000v-VPN0:\n            - CL-BR-C8000v-VPN0-INT\n            CL-BR-C8000v-VPN512:\n            - CL-BR-C8000v-VPN512-INT\n            CL-BR-C8000v-VPN10:\n            - CL-BR-C8000v-VPN10-INT\n</code></pre> <p>Note: The feature VPNs above are what we created in tasks 1-6.  The outcome of this playbook execution will be a device template with the corresponding feature templates. 2.  Execute this playbook.  </p>"},{"location":"#task-8-attach-device-template","title":"Task 8: Attach Device Template","text":"<ol> <li>Create a new yml file called \u201819_Attach_Device_Template.yml\u2019</li> </ol> <pre><code>- name: Attach Device Template\n  hosts: all\n  connection: local\n  gather_facts: no\n  vars_files:\n   - /home/dcloud/python-viptela/external_vars.yml\n  roles:\n    -  role: login\n       tags: CL-2001,CL-2001:login\n    -  role: attach_device_template\n       tags: lab2:attach\n       vars:\n           DeviceTemplateList:\n             CL-BR1-C8000v:\n               - csv-deviceIP: 1.1.1.101\n                 csv-deviceId: C8K-16AAD483-F5EC-AB00-465A-EDBA673652B7\n                 csv-host-name: CL-BR1-CEDGE8Kv-TEST\n                 //system/host-name: CL-BR1-CEDGE8Kv-TEST\n                 //system/site-id: 10\n                 //system/system-ip: 1.1.1.101\n           Change: false\n</code></pre> <p>Note: We may need to modify the csv-deviceId value with an 8000v from your pod.  An available UUID can be found in Configuration&gt;Devices.</p> <ol> <li>Execute this playbook.</li> </ol> <p>What did we just do?  Lets recap steps 1-8:</p> <ol> <li>We created 2 VPN feature templates (0 &amp; 512)</li> <li>We created a service VPN template (VPN10)</li> <li>We created 3 interface feature templates</li> <li>We associated these feature templates into a device template</li> <li>We attached this device template to a C8000v with the UUID of an C8000v within our lab environment.  </li> </ol> <p>Note: This is for demonstration purposes and this specific C8000v is not currently online.  We\u2019ve assigned this device template to this UUID should it come online it will have the configuration associated with these feature templates.  </p>"},{"location":"about/","title":"About this lab","text":""},{"location":"about/#lab-introduction","title":"Lab Introduction","text":"<p>We\u2019d like to introduce you to a simple SD-WAN deployment: One single border router.  In this lab the Viptela vManage, vSmart, vBond, and border router bring up sequence has already been completed. We have two hosts, a windows jumpbox and a linux host, that we\u2019ll leverage to provision our AWS account and execute our Ansible playbooks, respectively.  We\u2019ve already deployed Ansible on the Linux host so we\u2019re ready to dive into two very unique scenarios.  </p>"},{"location":"about/#lab-flow","title":"Lab Flow","text":"<p>In this lab, you will follow the lab guide on the scenarios below: Scenario 1: We\u2019ll explore the topics of Viptela device vs feature templates, Explore Ansible roles, Jinja2 templates, modules, etc.  We\u2019ll then leverage existing templates to reverse engineer the template structure to create our own! Scenario 2: Here we\u2019ll leverage a lab AWS environment to deploy Viptela\u2019s Cloud OnRamp for Multicloud using Ansible playbooks.  While most (all) of the playbooks used in this section are URI post/get calls, the outcome of this scenario is a deeper understanding of the APIs/Config Options available &amp; used during the OnRamp process.</p>"},{"location":"about/#lab-access","title":"Lab Access","text":"<p>Below table provides the IP addresses and credentials for the devices used in this lab: Note: You are able to access all devices via SSH and GUI after AnyConnect into dCloud. There is no remote desktop or any jump server required to access the lab. If you don't have AnyConnect VPN Client installed, you can download AnyConnect from here  https://developer.cisco.com/site/devnet/sandbox/anyconnect/</p>"},{"location":"appendix/","title":"Appendix","text":""},{"location":"appendix/#linux-commands","title":"Linux Commands","text":"<p>sudo; escalated root privileges rm -r; removes a file/directory more; Reads a file nano; Easy to read text editor pwd; prints the working directory ls; Lists files and subdirectories in the current directory cd; change directory \u201ccd &lt;directory name&gt;\u201d  cd ..; used to navigate back to the   </p>"},{"location":"sc_2_cont_edu/","title":"Continue your education!","text":"<p>BRKXAR-1000: Creating an Application-Optimized Secure Access Service Edge (SASE)-Enabled Architecture Kyle Barnes BRKXAR-2005: Segmentation Simplified: A Case Study of Meraki Adaptive Policy and Cisco TrustSec Praveen Poojary  BRKXAR-2015: Extend the Enterprise to the Cloud: AWS Cloud integration with Enterprise SD-WAN Praveen Poojary LABDEV-1102: Secure-X Orchestrator (SXO) - Manifest simplicity and efficiency via automation Navin Suvarna LABDEV-2007: NSO - Developing Python and Template-Based Service Navin Suvarna  </p>"},{"location":"sc_2_step_1/","title":"Step 1: Review Viptela SD-WAN API documentation","text":"<p>https://developer.cisco.com/docs/sdwan/</p> <p>Most of the APIs used in this document in the 'multicloud' section.  Before we can leverage ANY of the APIs we need to dig into the authentication section of the API documentation.  REMINDER: </p> <p>Every data service API request begins with the following Base URI. https:///dataservice"},{"location":"sc_2_validation/","title":"Validation","text":"<p>As mentioned at the beginning of Scenario 2, success for this Scenario is a validation of routing.   </p> <p>One thing that we notated at the very beginning were the host VPCs present in AWS.  There should have been two /16 subnets-one for each respective VPC: 10.0.0.0/16 &amp; 10.1.0.0/16. Log into BR1-CEDGE8Kv.  We\u2019re going to validate a couple of things. First, lets check the VRFs defined on this device.</p> <p>First, lets check the VRFs defined on this device.     show vrf</p> <p>What VRFs do you see? We should observe that VPN 10 is defined.  Why not VPN 20?  VPN 10 is present because of a feature template (BR1-C8000v-VPN10) that is associated with the device template (BR1-C8000v) assigned to the device.  </p> <p></p> <p>Do we have BFD associated with the transit VPC devices?    </p> <pre><code>show sdwan bfd session\n</code></pre> <p>We should see two BFD sessions from this device.</p> <p></p> <p>Lastly, lets check the routing in VRF 10.  </p> <pre><code>    show ip route vrf 10\n</code></pre> <p>We should see an OMP-learned route for the VPC prefix (either 10.0.0.0/16 or 10.1.0.0/16). Why don\u2019t we see both subnets? The intent we defined associating VPN 10 to the respective host VPC tag (VPN 10 to VPC Red) is how we associate the AWS VPCs to the SD-WAN VPNs.</p> <p> </p> <p>As a sanity check-what if we want the service VPN 10 to have access to the VPC associated with tag \u2018Blue\u2019  </p> <p>Does this require a template change?  Does this require an intent change? Hint: It\u2019s the latter.   Modify the Ansible playbook #4 so that VPN 10 has access to VPC \u2018Blue.\u2019 Perform the same verification as we did above-remember, the intent mapping takes a few minutes to perform. </p> <p> </p> <p>You\u2019re finished!  But as the tongue-in-cheek image above indicates, there is no actual finish line when it comes to education.  Hopefully this lab was insightful into the various capabilities available when it comes to Viptela SD-WAN automation using Ansible. If you found this lab insightful-Praveen, Navin, and Kyle all encourage you to please rate this lab.  Not only do you get a free pair of socks with enough reviews, but it also allows us to return to deliver these sorts of labs.</p>"},{"location":"scenario_2/","title":"Scenario 2","text":"<p>Welcome to Scenario 2! Here, we will walk step by step to understand EXACTLY what occurs when using the Onramp functionality within the Viptela SD-WAN solution.  </p> <p>Firstly, why do I care about extending the SD-WAN fabric to AWS?  Extending the SD-WAN fabric as close to the source/destination has the obvious benefit of maintaining segmentation (which VPNs (Virtual Private Networks) can connect to which host VPCs), but also it allows us to leverage capabilities like application aware routing to ensure we're using the BEST transit possible. Should I care about this, really? Are you asking this question because you already have a direct connect with AWS? Then no, this is useless information, and you can skip to the last page where we have a coupon for a free Shania Twain concert ticket! (Just kidding) You MIGHT care if you are not wanting to have to backhaul all your remote site application traffic through your point of AWS direct connect.  Some/most customers leverage a direct connect in a main campus location, so this means that your remote sites must traverse the various transports available to get to the campus only to then use the direct connect to AWS.  An alternative option is to use a direct internet connection so that your branch sites can get a direct (over the internet) path to the cloud-hosted application. Let us assume your branch site is already using a commercial internet circuit as one of its transports\u2026so why not cut out the middleman! Why am I using Ansible to do this? Can't I just use the GUI? Sure, but would you understand the SPECIFIC APIs OR the specific options available to extend the SD-WAN fabric? Furthermore, if you do not know ANYTHING (or very little) about Ansible, this session will leave you with an understanding of what could be possible.  </p> <p>Just because you can does not mean you should. Because you can, means you should. (for fun)</p> <ol> <li>Navigate back to the Windows jumphost.  The AWS instance should have been requested in the environment setup, but if you didn\u2019t already, please do so now.  Reminder, this takes a few minutes to complete  </li> <li>Click on \u2018Go to Account\u2019  </li> <li>Search for \u2018VPC\u2019 &amp; click on it.  </li> </ol> <p></p> <p>Review the x2 VPCs that are present.     Note: If you\u2019re not familiar with the concept of AWS VPCs, a VPC (or virtual private cloud) enables you to launch AWS resources into a virtual network that you've defined. This virtual network closely resembles a traditional network that you'd operate in your own data center, with the benefits of using the scalable infrastructure of AWS. The following diagram shows an example VPC. The VPC has one subnet in each of the Availability Zones in the Region.  A typical VPC definition includes a network (10.0.0.0/16 in this image) that can then be subnetted into smaller networks (10.0.1.0/24 &amp; 10.0.2.0/24).  </p> <p></p> <p>Note: There are two host VPCs in our lab environment.  Success for Scenario 2 is deployment of Cloud OnRamp for Multicloud and validation that we\u2019ve associated specific VPNs to specific VPCs, which can be verified by the routes associated with the VPCs.  </p> <p></p> <p>Here we can see that the two host VPCs have a /16 address block associated with them.</p>"},{"location":"scenario_2/#step-1-review-viptela-sd-wan-api-documentation","title":"Step 1: Review Viptela SD-WAN API documentation","text":"<p>https://developer.cisco.com/docs/sdwan/</p> <p>Most of the APIs used in this document in the 'multicloud' section.  Before we can leverage ANY of the APIs we need to dig into the authentication section of the API documentation.  REMINDER: </p> <p>Every data service API request begins with the following Base URI. https:///dataservice"},{"location":"scenario_2/#step-2-understand-the-cloud-onramp-for-multicloud-process","title":"Step 2: Understand the Cloud OnRamp for Multicloud Process","text":"<p>A.  Associate Cloud account (see variable file that you\u2019ve updated) B.  Cloud Global Settings C.  Create cloud gateway D.  Manage intent (via segmentation policies)</p>"},{"location":"scenario_2/#step-3a-associate-cloud-account","title":"Step 3A: Associate Cloud Account","text":"<p>(Don\u2019t configure this via the GUI, just showing it for visibility)</p> <p> </p> <p>You can see here that the /Multicloud/accounts API is used to associate the cloud account.  You can create and manage cloud accounts and configure global settings in Cisco vManage for AWS automation. You can create multiple accounts, pick a specific account for transit gateway, mark one or more accounts for transit VPC automation and use other accounts for host VPC discovery and connectivity.  </p> <p>The multicloud dashboard supports AWS key and IAM role models for authentication. IAM roles only work for AWS cloud deployed Cisco vManage, as this requires special AWS AssumeRole functions.  The cloudGatewayEnabled variable enables the account to deploy the cloud gateway solution (C8000v in the transit VPC + TGW).   </p>"},{"location":"scenario_2/#step-3b-cloud-global-settings","title":"Step 3B: Cloud Global Settings","text":"<p>Global settings enables you to set a configuration one time and repeat across regions and handle resource management globally (per cloud). The software image and instance size specified are used for instantiation of CSRs in the cloud as part of the cloud gateway.  </p> <p>Global settings include:  </p> <p>Software image: CSR software image used for creating cloud gateway.  There are two available software types: BYOL (Bring your own license) or PAYG (Pay as you go).  In today\u2019s lab we\u2019ll be using a BYOL image.  Specifically, 17.09.02a will be the software image used. </p> <p>AWS Instance Size: CSR instance size used depending upon bandwidth requirements.  </p> <p>Cloud Gateway Solution: The gateway solution used for AWS cloud. For example, transit gateway with transit VPC.  </p> <p>IP subnet pool: IP subnet pool used for transit VPC creation across regions. Subnet pool can be customized per cloud gateway using custom settings option, if desired. </p> <p>Intra-Tag Communication: Allows or denies communication between the VPCs under the same tag.  </p> <p>Default Route in Host VPCs: Default routes are automatically added to the main route table of the VPC that points to the transit gateway.  </p> <p>Full Mesh of Transit VPCs: Setup a full mesh connectivity between TVPCs of cloud gateways in different regions so as to carry site to site traffic (through CSRs) over public cloud backbone.  </p> <p>Site-to-Site Tunnel Encapsulation Type: The two options are GRE or IPsec  </p> <p> </p> <p>Note: The above image depicts the Transit Gateway \u2013 VPN based (using TVPC) against Transit Gateway \u2013 Connect Based (using TVPC) options. What\u2019s the difference?  One has IPsec and one has GRE?   As mentioned in the image above, the connect option is the latest capability available (~2 years old).  The choice for IPSec or GRE tunnels depends on customer requirements such as required bandwidth, security, use of public or private IP addresses for the tunnel endpoints.  Regardless, both options allow the SD-WAN to be extended into the transit VPC.  </p> <p> </p> <p>Note: As you can see, the softwareImageId is 17.05.01a-[product ID].  We\u2019ll use \u2018Cisco-C8K-17.09.02a-42cb6e93-8d9d-490b-a73c-e3e56077ffd1\u2019 in our request.  Why?  AMI version cannot exceed the vManage version.  Since we\u2019re running 20.9 version of vManage in today\u2019s lab, we\u2019re going to use the 17.09.02a version.    </p> <p>For today\u2019s lab, we\u2019ll also be using the Transit Gateway \u2013 VPN based (using TVPC) cloud gateway solution.</p>"},{"location":"scenario_2/#step-3c-create-cloud-gateway","title":"Step 3C: Create cloud gateway","text":"<p>AKA, where the magic happens! This is the step where the TGW &amp; Transit VPC (C8000v devices) are deployed! What do we need to do in preparation for this step? 1.  Log into your AWS console 2.  Go to the AWS Marketplace</p> <p> </p> <ol> <li>Search for \u20188000v\u2019</li> </ol> <p> </p> <ol> <li>In this lab setup this has already been performed, but a new deployment would require subscribing.  </li> </ol> <p> </p> <p>Note: Take note that running EC2/infrastructure cost of running the VMs are NOT free.  Also, the costs differ depending on the selected region.  Select US West and then US East to compare the pricing differences.</p> <ol> <li>Validate permissions-In this lab setup this won\u2019t be an issue, but normal local administrator rights are insufficient.  We specifically need the AmazonEC2FullAccess &amp; AmazonVPCFullAccess permissions associated with the account you supplied on step 6A for the automation deployment to be successful.  </li> </ol> <p> </p> <p>Note: This is a user group called Admins that we\u2019ve associated the privileges to.  You may not have access to IAM as part of this lab but see the above image for demonstration purposes.  Reminder, this is not necessarily a best practice, and you should be following a practice of least privilege and it is common to associate an account specifically for AWS&lt;&gt;vManage interconnect.</p> <p> </p> <p>Reviewing the screenshot above, we\u2019re going to ignore the settings section as these configurations are already present in our global config.  This settings section is meant to override the global settings, should that be required.  </p> <p>There is a field that we must populate, the UUID section, which will specify WHICH virtual devices we intent to deploy.  </p> <p> </p> <ol> <li>Navigate to Configuration&gt;Devices</li> <li> <p>You can see a number of devices with \u2018Chassis Number\u2019 in the first column-these are the UUIDs.  Copy/paste two UUIDs into your notepad for the deployment section.  </p> </li> <li> <p>Navigate to Configuration&gt;Templates</p> </li> </ol> <p> </p> <ol> <li>Navigate to \u201cDevice Templates\u201d and take note of the \u201cAWS-cat8kv-multicloud\u201d template.  A normal practice would be to click \u2018attach devices\u2019-we\u2019re going to use Ansible for this.  </li> </ol> <p> </p> <ol> <li>This template will attach when the device comes online (when we configure the step within the OnRamp for Multicloud Create Cloud Gateway step)</li> </ol> <p> </p>"},{"location":"scenario_2/#step-3d-manage-intent-via-segmentation-policies","title":"Step 3D: Manage intent (via segmentation policies)","text":"<p>What?  If I keep saying \u2018This is where the magic happens\u2019  .. This is where MORE magic happens!  This is where we specifically define which SD-WAN VPNs can reach which AWS VPCs!  Also, we can specify which VPC to VPC traffic we wish to permit.</p> <p> </p> <p>Within the GUI, this is a lot prettier and easier to understand.</p> <p> </p> <p>Note: Here you can see that VPN65530 can access the 5StarLab VPC &amp; VPN10 can access the test VPC (bidirectionally).  VPN 10 CANNOT access the 5StarLab VPC.  </p> <p>Now that we understand the steps, reviewed what variables are needed, and have prepared our AWS environment, we\u2019re ready to get into Ansible!</p>"},{"location":"scenario_2/#step-4-deployment","title":"Step 4: Deployment","text":"<p>We\u2019re going to be creating multiple ansible playbooks.  Each playbook will perform a step in the process.  You\u2019ll see the syntax for each of the playbooks have a similar beginning:   </p> <p>\u2022   Hosts: Uses the host file to determine where to run the play against.  We only have the IP address associated with vManage there.  </p> <p>\u2022   Gather_facts: This is time saving step.  We do not need to gather any information on the hosts in which the plays are run against so we skip those.  </p> <p>\u2022   Connection: A normal Ansible play would use SSH and deploy a python script onto the host to execute.  Since we are executing this on the Ansible control node we need to specify local.  </p> <p>\u2022   Vars_files: In this space we must associate our pod specifics.  Any variables unique to a pod will go here!    </p> <p>\u2022   Get Cookie task: Before we can use any of the vManage APIs we first need to request a cookie (supplying the username/password).  We\u2019ll use this cookie as a header in the subsequent API requests.  </p> <p>\u2022   Get XSRF token task: Like the cookie, we\u2019ll need an XSRF token, or cross-site request forgery prevention token, which is required for most POST operations.  This will also be used as a header in the POST requests.   </p> <p>\u2022   The \u2018register\u2019 keyword stores the value of the specific task to be used in later tasks.  Since registered variables are stored in memory, it\u2019s not possible to use them in future plays, and they are only available for the current playbook run.  </p>"},{"location":"scenario_2/#associate-cloud-account","title":"Associate Cloud account","text":"<pre><code>- name: Step 1; Apply AWS credentials\nhosts: vmanage\ngather_facts: no\nconnection: local\n#ALL YOUR POD/AWS SPECIFICS GO HERE#\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\ntasks:\n- name: Get Cookies\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/j_security_check\n    method: POST\n    body_format: form-urlencoded\n    validate_certs: False\n    body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n- name: Output Cookie Info\n    ansible.builtin.debug:\n    var: login.cookies\n- name: Get XSRF\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/client/token\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n- name: Cookie Output\n    ansible.builtin.debug:\n    var: cookie_output.content\n###########################################################################\n- name: Apply info\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/accounts\n    method: POST\n    body_format: json\n    body: \"{\\\"cloudType\\\":\\\"AWS\\\",\\\"accountName\\\":\\\"{{AWS_Account_Name}}\\\",\\\"description\\\":\\\"{{Description}}\\\",\\\"awsKeyCredentials\\\":{\\\"apiKey\\\":\\\"{{AWS_Access_KEY}}\\\",\\\"secretKey\\\":\\\"{{AWS_Secret_KEY}}\\\"},\\\"cloudGatewayEnabled\\\":\\\"tru\ne\\\"}\"\n    validate_certs: false\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n</code></pre> <p>We can save this file and run it to validate that there are no issues found.  The syntax to run the playbook is \u2018ansible-playbook \u2019.  If we run the playbook as-is we should see something like the following: <p> </p> <p>(Sorry for the small text, but green is good)</p> <p>What we can see here is that we\u2019re making a POST method call, with our cookie and XSRF token from earlier with a bunch of mess in the body format.  This is a JSON text string of the following:</p> <pre><code>{\n    \"cloudType\": \"AWS\",\n    \"accountName\": \"&lt;whatever you have in your variable file&gt;\",\n    \"description\": \"&lt;whatever you have in your variable file&gt;\",\n    \"awsKeyCredentials\": {\n    \"apiKey\": \"&lt;whatever you have in your variable file&gt;\",\n    \"secretKey\": \"&lt;whatever you have in your variable file&gt;\"\n    },\n    \"cloudGatewayEnabled\": \"true\"\n}\n</code></pre> <p>Note: We\u2019re lazy.  You can use a JSON to text string formatter online.  Copy/paste from the API documentation and then modify the values. We can confirm in the GUI if the account settings have been applied.  </p> <p></p> <p>Again, sorry for the small text, but validate in the Cloud Account Management section-it may require a refresh</p>"},{"location":"scenario_2/#cloud-global-settings","title":"Cloud global settings","text":"<p>Note: Understanding the product ID will be required for the global settings API.  </p> <pre><code>- name: Step 2; Apply Global Settings\nhosts: vmanage\ngather_facts: no\nconnection: local\n#ALL YOUR POD/AWS SPECIFICS GO HERE#\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\ntasks:\n- name: Get Cookies\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/j_security_check\n    method: POST\n    body_format: form-urlencoded\n    validate_certs: False\n    body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n- name: Output Cookie Info\n    ansible.builtin.debug:\n    var: login.cookies\n- name: Get XSRF\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/client/token\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n- name: Cookie Output\n    ansible.builtin.debug:\n    var: cookie_output.content\n##################################################################################\n- name: Apply Global Settings\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/settings/global\n    method: POST\n    body_format: json\n    body: \"{\\\"cloudGatewaySolution\\\":\\\"tgw_tvpc\\\",\\\"cloudType\\\":\\\"AWS\\\",\\\"name\\\":\\\"{{AWS_Account_Name}}\\\",\\\"enableAutoCorrect\\\":true,\\\"enablePeriodicAudit\\\":true,\\\"softwareImageId\\\":\\\"Cisco-C8K-17.09.02a-42cb6e93-8d9d-490b-a73c-e3e56077ffd1\\\",\\\"instanceSize\\\":\\\"t3.medium\\\",\\\"intraTagComm\\\":true,\\\"ipSubnetPool\\\":\\\"192.168.100.0/24\\\",\\\"accountId\\\":\\\"{{AWS_Account_ID}}\\\",\\\"cgwBgpAsnOffset\\\":64520,\\\"mapTvpc\\\":true,\\\"programDefaultRoute\\\":true,\\\"region\\\":\\\"us-east-1\\\",\\\"tunnelType\\\":\\\"ipsec\\\"}\"\n    validate_certs: false\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n</code></pre> <p>Did we see all green?  Verify in the vManage GUI global settings section!  </p> <p> </p>"},{"location":"scenario_2/#discover-host-private-networks","title":"Discover Host Private Networks","text":"<pre><code>- name: Step 3; Discover AWS Host VPCs\nhosts: vmanage\ngather_facts: no\nconnection: local\n#ALL YOUR POD/AWS SPECIFICS GO HERE#\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\ntasks:\n- name: Get Cookies\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/j_security_check\n    method: POST\n    body_format: form-urlencoded\n    validate_certs: False\n    body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n- name: Output Cookie Info\n    ansible.builtin.debug:\n    var: login.cookies\n- name: Get XSRF\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/client/token\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n- name: Cookie Output\n    ansible.builtin.debug:\n    var: cookie_output.content\n##################################################################################\n- name: Get Host VPCs\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/hostvpc?cloudType=AWS\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n    register: VPC\n- name: Output VPCs\n    ansible.builtin.debug:\n    var: VPC.json.data\n- name: Save\n    ansible.builtin.copy:\n    content: \"{{ VPC.json.data }}\"\n    dest: /home/dcloud/python-viptela/dest_file.json\n</code></pre> <p>Note: Take the VPC IDs and add the values to your external_vars file.  </p> <p> </p> <p>Verifying in the GUI, we should see the same output.  </p>"},{"location":"scenario_2/#tag-aws-host-vpcs","title":"Tag AWS Host VPCs","text":"<pre><code>- name: Step 4; Tag AWS Host VPCs\nhosts: vmanage\ngather_facts: no\nconnection: local\n#ALL YOUR POD/AWS SPECIFICS GO HERE#\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\nvars:\n    jsondata: \"{{ lookup('file', 'dest_file.json') | from_json }}\"\ntasks:\n- name: Get Cookies\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/j_security_check\n    method: POST\n    body_format: form-urlencoded\n    validate_certs: False\n    body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n- name: Output Cookie Info\n    ansible.builtin.debug:\n    var: login.cookies\n- name: Get XSRF\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/client/token\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n- name: Cookie Output\n    ansible.builtin.debug:\n    var: cookie_output.content\n###########################################################################\n- name: RED VPC\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/hostvpc/tags?cloudType=AWS\n    method: POST\n    body_format: json\n    body: \"{\\\"tagName\\\":\\\"Red\\\",\\\"interconnectTag\\\":false,\\\"hostVpcs\\\":[{\\\"accountId\\\":\\\"{{ AWS_Account_ID }}\\\",\\\"accountName\\\":\\\"{{ AWS_Account_Name }}\\\",\\\"region\\\":\\\"us-east-1\\\",\\\"cloudType\\\":\\\"AWS\\\",\\\"hostVpcId\\\":\\\"{{Host_VPC_1_ID}}\n\\\",\\\"hostVpcName\\\":\\\"test-vpc-1\\\"}]}\"\n    validate_certs: false\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n- name: Print\n    ansible.builtin.debug:\n    msg: \"VPC {{Host_VPC_1_ID}} given the tag of Red\"\n- name: Sleep for 15 seconds and continue with play\n    ansible.builtin.wait_for:\n    timeout: 15\n    delegate_to: localhost\n- name: BLUE VPC\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/hostvpc/tags?cloudType=AWS\n    method: POST\n    body_format: json\n    body: \"{\\\"tagName\\\":\\\"Blue\\\",\\\"interconnectTag\\\":false,\\\"hostVpcs\\\":[{\\\"accountId\\\":\\\"{{ AWS_Account_ID }}\\\",\\\"accountName\\\":\\\"{{ AWS_Account_Name }}\\\",\\\"region\\\":\\\"us-east-1\\\",\\\"cloudType\\\":\\\"AWS\\\",\\\"hostVpcId\\\":\\\"{{Host_VPC_2_ID}\n}\\\",\\\"hostVpcName\\\":\\\"test-vpc-2\\\"}]}\"\n    validate_certs: false\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n- name: Print\n    ansible.builtin.debug:\n    msg: \"VPC {{Host_VPC_2_ID}} given the tag of Blue\"\n</code></pre> <p>Note: One thing you may note is the ansible.builtin.wait_for module.  This is a module to delay the subsequent task for a defined amount of time.  We\u2019ve specified a wait of 15 seconds as you\u2019d otherwise get an error trying to apply the Blue tag until the Red tag application is complete.  </p> <p></p>"},{"location":"scenario_2/#create-cloud-gateway","title":"Create Cloud Gateway","text":"<p>Note: This step takes a few minutes to deploy. Before we can deploy our cloud routers, we first need to associate a template.  We\u2019ll be using the default device template \u2018AWS-cat8kv-multicloud.\u2019  As mentioned in the section prior, this is done in the GUI at Configuration&gt;Templates&gt;Device Templates.  </p> <p>But\u2026we\u2019re doing this in ansible.  Recall task 8 from scenario 1-we\u2019re going to use the same role.  We have a playbook called \u20185a_Attach_AWS_Template.yml\u2019 which should look very similar to \u201819_Attach_Device_Template.yml.\u2019  The main difference being the addition of another variable: \u201c/0/GigabitEthernet2//interface/tunnel-interface/color/value: default\u201d</p> <pre><code>- name: Attach AWS Device Template\nhosts: all\nconnection: local\ngather_facts: no\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\nroles:\n    -  role: login\n    tags: CL-2001,CL-2001:login\n    -  role: attach_device_template\n    tags: lab2:attach\n    vars:\n        DeviceTemplateList:\n            AWS-cat8kv-multicloud:\n            - csv-deviceIP: \"-\"\n                csv-status: \"complete\"\n                csv-deviceId:  \"{{ UUID_1 }}\"\n                csv-host-name: \"-\"\n                //system/host-name: \"AWS1\"\n                //system/site-id: \"5\"\n                //system/system-ip: \"2.2.2.1\"\n                /0/GigabitEthernet2//interface/tunnel-interface/color/value: \"default\"\n            - csv-deviceIP: \"-\"\n                csv-status: \"complete\"\n                csv-deviceId:  \"{{ UUID_2 }}\"\n                csv-host-name: \"-\"\n                //system/host-name: \"AWS2\"\n                //system/site-id: \"5\"\n                //system/system-ip: \"2.2.2.2\"\n                /0/GigabitEthernet2//interface/tunnel-interface/color/value: \"default\"\n</code></pre> <p>Note: In this example we\u2019re going to reference the external_vars.yml file to use the pod-specific UUIDs. </p> <p>Execute this playbook.  </p> <pre><code>- name: Step 5; Create Cloud Gateway\nhosts: vmanage\ngather_facts: no\nconnection: local\n#ALL YOUR POD/AWS SPECIFICS GO HERE#\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\nvars:\n    jsondata: \"{{ lookup('file', 'dest_file.json') | from_json }}\"\ntasks:\n- name: Get Cookies\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/j_security_check\n    method: POST\n    body_format: form-urlencoded\n    validate_certs: False\n    body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n- name: Output Cookie Info\n    ansible.builtin.debug:\n    var: login.cookies\n- name: Get XSRF\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/client/token\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n- name: Cookie Output\n    ansible.builtin.debug:\n    var: cookie_output.content\n##################################################################################\n- name: Deploy CGW\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/cloudgateway\n    method: POST\n    body_format: json\n    validate_certs: False\n    body: \"{\\\"accountId\\\":\\\"{{AWS_Account_ID}}\\\",\\\"cloudType\\\":\\\"AWS\\\",\\\"region\\\":\\\"us-east-1\\\",\\\"cloudGatewayName\\\":\\\"CL2023_CGW\\\",\\\"devices\\\":[\\\"{{UUID_1}}\\\",\\\"{{UUID_2}}\\\"],\\\"description\\\":\\\"\\\"}\"\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n    register: results\n</code></pre> <p>Configuration&gt;Templates</p> <p></p> <p>Note: We can see here that the two cloud routers have the AWS template assigned (attached).  </p>"},{"location":"scenario_2/#manage-intent","title":"Manage Intent","text":"<pre><code>- name: Step 6; Manage Intent\nhosts: vmanage\ngather_facts: no\nconnection: local\n#ALL YOUR POD/AWS SPECIFICS GO HERE#\nvars_files:\n- /home/dcloud/python-viptela/external_vars.yml\nvars:\n    jsondata: \"{{ lookup('file', 'dest_file.json') | from_json }}\"\ntasks:\n- name: Get Cookies\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/j_security_check\n    method: POST\n    body_format: form-urlencoded\n    validate_certs: False\n    body:\n        j_username: \"{{ USERNAME }}\"\n        j_password: \"{{ PASSWORD }}\"\n    register: login\n- name: Output Cookie Info\n    ansible.builtin.debug:\n    var: login.cookies\n- name: Get XSRF\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/client/token\n    method: GET\n    body_format: json\n    validate_certs: False\n    return_content: true\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n    register: cookie_output\n- name: Cookie Output\n    ansible.builtin.debug:\n    var: cookie_output.content\n##################################################################################\n- name: Manage Intent\n    ansible.builtin.uri:\n    url: https://{{ VMANAGE_IP }}/dataservice/multicloud/map?cloudType=AWS\n    method: POST\n    body_format: json\n    validate_certs: False\n    body: \"{\\\"cloudType\\\":\\\"AWS\\\",\\\"connMatrix\\\":[{\\\"srcType\\\":\\\"vpn\\\",\\\"srcId\\\":\\\"10\\\",\\\"conn\\\":\\\"enabled\\\",\\\"destId\\\":\\\"Red\\\",\\\"destType\\\":\\\"tag\\\"},{\\\"srcType\\\":\\\"tag\\\",\\\"srcId\\\":\\\"Red\\\",\\\"conn\\\":\\\"enabled\\\",\\\"destId\\\":\\\"10\\\",\\\"destT\nype\\\":\\\"vpn\\\"}]}\"\n    headers:\n        Cookie: \"{{ login.cookies_string }}\"\n        X-XSRF-TOKEN:  \"{{ cookie_output.content }}\"\n</code></pre> <p>Note: AWS cloud operations can take up to 40-60 mins to complete mapping the intent management.  In our experience testing this lab, it takes around 5-10 minutes to get to an \u2018all green\u2019 state:  </p> <p></p> <p></p> <p>Once you see all green it indicates the TVPC C8000vs are reachable and that there are IPsec tunnels established to the TGW.  Proceed to validation.</p>"}]}